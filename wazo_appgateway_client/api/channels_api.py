# coding: utf-8

"""
    localhost:8088

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 5.1.1
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from wazo_appgateway_client.api_client import ApiClient
from wazo_appgateway_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ChannelsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def channels_channel_id_answer_post(self, channel_id, **kwargs):  # noqa: E501
        """Answer a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_answer_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_answer_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_answer_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Answer a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_answer_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_answer_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_answer_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/answer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_continue_post(self, channel_id, **kwargs):  # noqa: E501
        """Exit application; continue execution in the dialplan.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_continue_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param context: The context to continue to.
        :type context: str
        :param extension: The extension to continue to.
        :type extension: str
        :param priority: The priority to continue to.
        :type priority: int
        :param label: The label to continue to - will supersede 'priority' if both are provided.
        :type label: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_continue_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_continue_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Exit application; continue execution in the dialplan.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_continue_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param context: The context to continue to.
        :type context: str
        :param extension: The extension to continue to.
        :type extension: str
        :param priority: The priority to continue to.
        :type priority: int
        :param label: The label to continue to - will supersede 'priority' if both are provided.
        :type label: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'context',
            'extension',
            'priority',
            'label',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_continue_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_continue_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'context' in local_var_params and local_var_params['context'] is not None:  # noqa: E501
            query_params.append(('context', local_var_params['context']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501
        if 'priority' in local_var_params and local_var_params['priority'] is not None:  # noqa: E501
            query_params.append(('priority', local_var_params['priority']))  # noqa: E501
        if 'label' in local_var_params and local_var_params['label'] is not None:  # noqa: E501
            query_params.append(('label', local_var_params['label']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/continue', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_delete(self, channel_id, **kwargs):  # noqa: E501
        """Delete (i.e. hangup) a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param reason_code: The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings
        :type reason_code: str
        :param reason: Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.
        :type reason: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_delete_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Delete (i.e. hangup) a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param reason_code: The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings
        :type reason_code: str
        :param reason: Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.
        :type reason: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'reason_code',
            'reason',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'reason_code' in local_var_params and local_var_params['reason_code'] is not None:  # noqa: E501
            query_params.append(('reason_code', local_var_params['reason_code']))  # noqa: E501
        if 'reason' in local_var_params and local_var_params['reason'] is not None:  # noqa: E501
            query_params.append(('reason', local_var_params['reason']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_dial_post(self, channel_id, **kwargs):  # noqa: E501
        """Dial a created channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_dial_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param caller: Channel ID of caller
        :type caller: str
        :param timeout: Dial timeout
        :type timeout: int
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_dial_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_dial_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Dial a created channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_dial_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param caller: Channel ID of caller
        :type caller: str
        :param timeout: Dial timeout
        :type timeout: int
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'caller',
            'timeout',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_dial_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_dial_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'caller' in local_var_params and local_var_params['caller'] is not None:  # noqa: E501
            query_params.append(('caller', local_var_params['caller']))  # noqa: E501
        if 'timeout' in local_var_params and local_var_params['timeout'] is not None:  # noqa: E501
            query_params.append(('timeout', local_var_params['timeout']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/dial', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_dtmf_post(self, channel_id, **kwargs):  # noqa: E501
        """Send provided DTMF to a given channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_dtmf_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param dtmf: DTMF To send.
        :type dtmf: str
        :param before: Amount of time to wait before DTMF digits (specified in milliseconds) start.
        :type before: int
        :param between: Amount of time in between DTMF digits (specified in milliseconds).
        :type between: int
        :param duration: Length of each DTMF digit (specified in milliseconds).
        :type duration: int
        :param after: Amount of time to wait after DTMF digits (specified in milliseconds) end.
        :type after: int
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_dtmf_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_dtmf_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Send provided DTMF to a given channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_dtmf_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param dtmf: DTMF To send.
        :type dtmf: str
        :param before: Amount of time to wait before DTMF digits (specified in milliseconds) start.
        :type before: int
        :param between: Amount of time in between DTMF digits (specified in milliseconds).
        :type between: int
        :param duration: Length of each DTMF digit (specified in milliseconds).
        :type duration: int
        :param after: Amount of time to wait after DTMF digits (specified in milliseconds) end.
        :type after: int
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'dtmf',
            'before',
            'between',
            'duration',
            'after',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_dtmf_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_dtmf_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'dtmf' in local_var_params and local_var_params['dtmf'] is not None:  # noqa: E501
            query_params.append(('dtmf', local_var_params['dtmf']))  # noqa: E501
        if 'before' in local_var_params and local_var_params['before'] is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if 'between' in local_var_params and local_var_params['between'] is not None:  # noqa: E501
            query_params.append(('between', local_var_params['between']))  # noqa: E501
        if 'duration' in local_var_params and local_var_params['duration'] is not None:  # noqa: E501
            query_params.append(('duration', local_var_params['duration']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/dtmf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_get(self, channel_id, **kwargs):  # noqa: E501
        """Channel details.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_get(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_get_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_get_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Channel details.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_get_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels/{channelId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_hold_delete(self, channel_id, **kwargs):  # noqa: E501
        """Remove a channel from hold.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_hold_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_hold_delete_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_hold_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Remove a channel from hold.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_hold_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_hold_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_hold_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/hold', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_hold_post(self, channel_id, **kwargs):  # noqa: E501
        """Hold a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_hold_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_hold_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_hold_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Hold a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_hold_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_hold_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_hold_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/hold', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_moh_delete(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing music on hold to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_moh_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_moh_delete_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_moh_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing music on hold to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_moh_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_moh_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_moh_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/moh', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_moh_post(self, channel_id, **kwargs):  # noqa: E501
        """Play music on hold to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_moh_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param moh_class: Music on hold class to use
        :type moh_class: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_moh_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_moh_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Play music on hold to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_moh_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param moh_class: Music on hold class to use
        :type moh_class: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'moh_class',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_moh_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_moh_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'moh_class' in local_var_params and local_var_params['moh_class'] is not None:  # noqa: E501
            query_params.append(('mohClass', local_var_params['moh_class']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/moh', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_move_post(self, channel_id, app, **kwargs):  # noqa: E501
        """Move the channel from one Stasis application to another.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_move_post(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: The channel will be passed to this Stasis application. (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'.
        :type app_args: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_move_post_with_http_info(channel_id, app, **kwargs)  # noqa: E501

    def channels_channel_id_move_post_with_http_info(self, channel_id, app, **kwargs):  # noqa: E501
        """Move the channel from one Stasis application to another.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_move_post_with_http_info(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: The channel will be passed to this Stasis application. (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'.
        :type app_args: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'app',
            'app_args',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_move_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_move_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if self.api_client.client_side_validation and ('app' not in local_var_params or  # noqa: E501
                                                        local_var_params['app'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `app` when calling `channels_channel_id_move_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'app_args' in local_var_params and local_var_params['app_args'] is not None:  # noqa: E501
            query_params.append(('appArgs', local_var_params['app_args']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_mute_delete(self, channel_id, **kwargs):  # noqa: E501
        """Unmute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_mute_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to unmute audio
        :type direction: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_mute_delete_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_mute_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Unmute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_mute_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to unmute audio
        :type direction: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'direction',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_mute_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_mute_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'direction' in local_var_params and local_var_params['direction'] is not None:  # noqa: E501
            query_params.append(('direction', local_var_params['direction']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/mute', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_mute_post(self, channel_id, **kwargs):  # noqa: E501
        """Mute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_mute_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to mute audio
        :type direction: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_mute_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_mute_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Mute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_mute_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to mute audio
        :type direction: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'direction',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_mute_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_mute_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'direction' in local_var_params and local_var_params['direction'] is not None:  # noqa: E501
            query_params.append(('direction', local_var_params['direction']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/mute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_play_playback_id_post(self, channel_id, playback_id, media, **kwargs):  # noqa: E501
        """Start playback of media and specify the playbackId.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_play_playback_id_post(channel_id, playback_id, media, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param playback_id: Playback ID. (required)
        :type playback_id: str
        :param media: Media URIs to play. (required)
        :type media: list[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Playback
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_play_playback_id_post_with_http_info(channel_id, playback_id, media, **kwargs)  # noqa: E501

    def channels_channel_id_play_playback_id_post_with_http_info(self, channel_id, playback_id, media, **kwargs):  # noqa: E501
        """Start playback of media and specify the playbackId.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_play_playback_id_post_with_http_info(channel_id, playback_id, media, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param playback_id: Playback ID. (required)
        :type playback_id: str
        :param media: Media URIs to play. (required)
        :type media: list[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Playback, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'playback_id',
            'media',
            'lang',
            'offsetms',
            'skipms',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_play_playback_id_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_play_playback_id_post`")  # noqa: E501
        # verify the required parameter 'playback_id' is set
        if self.api_client.client_side_validation and ('playback_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['playback_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `playback_id` when calling `channels_channel_id_play_playback_id_post`")  # noqa: E501
        # verify the required parameter 'media' is set
        if self.api_client.client_side_validation and ('media' not in local_var_params or  # noqa: E501
                                                        local_var_params['media'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `media` when calling `channels_channel_id_play_playback_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501
        if 'playback_id' in local_var_params:
            path_params['playbackId'] = local_var_params['playback_id']  # noqa: E501

        query_params = []
        if 'media' in local_var_params and local_var_params['media'] is not None:  # noqa: E501
            query_params.append(('media', local_var_params['media']))  # noqa: E501
            collection_formats['media'] = 'multi'  # noqa: E501
        if 'lang' in local_var_params and local_var_params['lang'] is not None:  # noqa: E501
            query_params.append(('lang', local_var_params['lang']))  # noqa: E501
        if 'offsetms' in local_var_params and local_var_params['offsetms'] is not None:  # noqa: E501
            query_params.append(('offsetms', local_var_params['offsetms']))  # noqa: E501
        if 'skipms' in local_var_params and local_var_params['skipms'] is not None:  # noqa: E501
            query_params.append(('skipms', local_var_params['skipms']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Playback",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/play/{playbackId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_play_post(self, channel_id, media, **kwargs):  # noqa: E501
        """Start playback of media.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_play_post(channel_id, media, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param media: Media URIs to play. (required)
        :type media: list[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param playback_id: Playback ID.
        :type playback_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Playback
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_play_post_with_http_info(channel_id, media, **kwargs)  # noqa: E501

    def channels_channel_id_play_post_with_http_info(self, channel_id, media, **kwargs):  # noqa: E501
        """Start playback of media.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_play_post_with_http_info(channel_id, media, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param media: Media URIs to play. (required)
        :type media: list[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param playback_id: Playback ID.
        :type playback_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Playback, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'media',
            'lang',
            'offsetms',
            'skipms',
            'playback_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_play_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_play_post`")  # noqa: E501
        # verify the required parameter 'media' is set
        if self.api_client.client_side_validation and ('media' not in local_var_params or  # noqa: E501
                                                        local_var_params['media'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `media` when calling `channels_channel_id_play_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'media' in local_var_params and local_var_params['media'] is not None:  # noqa: E501
            query_params.append(('media', local_var_params['media']))  # noqa: E501
            collection_formats['media'] = 'multi'  # noqa: E501
        if 'lang' in local_var_params and local_var_params['lang'] is not None:  # noqa: E501
            query_params.append(('lang', local_var_params['lang']))  # noqa: E501
        if 'offsetms' in local_var_params and local_var_params['offsetms'] is not None:  # noqa: E501
            query_params.append(('offsetms', local_var_params['offsetms']))  # noqa: E501
        if 'skipms' in local_var_params and local_var_params['skipms'] is not None:  # noqa: E501
            query_params.append(('skipms', local_var_params['skipms']))  # noqa: E501
        if 'playback_id' in local_var_params and local_var_params['playback_id'] is not None:  # noqa: E501
            query_params.append(('playbackId', local_var_params['playback_id']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Playback",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/play', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_post(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate with id).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_post(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param channel_id: The unique id to assign the channel on creation. (required)
        :type channel_id: str
        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_post_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501

    def channels_channel_id_post_with_http_info(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate with id).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_post_with_http_info(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param channel_id: The unique id to assign the channel on creation. (required)
        :type channel_id: str
        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'endpoint',
            'extension',
            'context',
            'priority',
            'label',
            'app',
            'app_args',
            'caller_id',
            'timeout',
            'other_channel_id',
            'originator',
            'formats',
            'x_asterisk_id',
            'containers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_post`")  # noqa: E501
        # verify the required parameter 'endpoint' is set
        if self.api_client.client_side_validation and ('endpoint' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint` when calling `channels_channel_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'endpoint' in local_var_params and local_var_params['endpoint'] is not None:  # noqa: E501
            query_params.append(('endpoint', local_var_params['endpoint']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501
        if 'context' in local_var_params and local_var_params['context'] is not None:  # noqa: E501
            query_params.append(('context', local_var_params['context']))  # noqa: E501
        if 'priority' in local_var_params and local_var_params['priority'] is not None:  # noqa: E501
            query_params.append(('priority', local_var_params['priority']))  # noqa: E501
        if 'label' in local_var_params and local_var_params['label'] is not None:  # noqa: E501
            query_params.append(('label', local_var_params['label']))  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'app_args' in local_var_params and local_var_params['app_args'] is not None:  # noqa: E501
            query_params.append(('appArgs', local_var_params['app_args']))  # noqa: E501
        if 'caller_id' in local_var_params and local_var_params['caller_id'] is not None:  # noqa: E501
            query_params.append(('callerId', local_var_params['caller_id']))  # noqa: E501
        if 'timeout' in local_var_params and local_var_params['timeout'] is not None:  # noqa: E501
            query_params.append(('timeout', local_var_params['timeout']))  # noqa: E501
        if 'other_channel_id' in local_var_params and local_var_params['other_channel_id'] is not None:  # noqa: E501
            query_params.append(('otherChannelId', local_var_params['other_channel_id']))  # noqa: E501
        if 'originator' in local_var_params and local_var_params['originator'] is not None:  # noqa: E501
            query_params.append(('originator', local_var_params['originator']))  # noqa: E501
        if 'formats' in local_var_params and local_var_params['formats'] is not None:  # noqa: E501
            query_params.append(('formats', local_var_params['formats']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'containers' in local_var_params:
            body_params = local_var_params['containers']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels/{channelId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_record_post(self, channel_id, name, format, **kwargs):  # noqa: E501
        """Start a recording.  # noqa: E501

        Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_record_post(channel_id, name, format, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param name: Recording's filename (required)
        :type name: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit
        :type max_duration_seconds: int
        :param max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit
        :type max_silence_seconds: int
        :param if_exists: Action to take if a recording with the same name already exists.
        :type if_exists: str
        :param beep: Play beep when recording begins
        :type beep: bool
        :param terminate_on: DTMF input to terminate recording
        :type terminate_on: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LiveRecording
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_record_post_with_http_info(channel_id, name, format, **kwargs)  # noqa: E501

    def channels_channel_id_record_post_with_http_info(self, channel_id, name, format, **kwargs):  # noqa: E501
        """Start a recording.  # noqa: E501

        Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_record_post_with_http_info(channel_id, name, format, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param name: Recording's filename (required)
        :type name: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit
        :type max_duration_seconds: int
        :param max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit
        :type max_silence_seconds: int
        :param if_exists: Action to take if a recording with the same name already exists.
        :type if_exists: str
        :param beep: Play beep when recording begins
        :type beep: bool
        :param terminate_on: DTMF input to terminate recording
        :type terminate_on: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LiveRecording, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'name',
            'format',
            'max_duration_seconds',
            'max_silence_seconds',
            'if_exists',
            'beep',
            'terminate_on',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_record_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_record_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `channels_channel_id_record_post`")  # noqa: E501
        # verify the required parameter 'format' is set
        if self.api_client.client_side_validation and ('format' not in local_var_params or  # noqa: E501
                                                        local_var_params['format'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `format` when calling `channels_channel_id_record_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'format' in local_var_params and local_var_params['format'] is not None:  # noqa: E501
            query_params.append(('format', local_var_params['format']))  # noqa: E501
        if 'max_duration_seconds' in local_var_params and local_var_params['max_duration_seconds'] is not None:  # noqa: E501
            query_params.append(('maxDurationSeconds', local_var_params['max_duration_seconds']))  # noqa: E501
        if 'max_silence_seconds' in local_var_params and local_var_params['max_silence_seconds'] is not None:  # noqa: E501
            query_params.append(('maxSilenceSeconds', local_var_params['max_silence_seconds']))  # noqa: E501
        if 'if_exists' in local_var_params and local_var_params['if_exists'] is not None:  # noqa: E501
            query_params.append(('ifExists', local_var_params['if_exists']))  # noqa: E501
        if 'beep' in local_var_params and local_var_params['beep'] is not None:  # noqa: E501
            query_params.append(('beep', local_var_params['beep']))  # noqa: E501
        if 'terminate_on' in local_var_params and local_var_params['terminate_on'] is not None:  # noqa: E501
            query_params.append(('terminateOn', local_var_params['terminate_on']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "LiveRecording",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/record', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_redirect_post(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Redirect the channel to a different location.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_redirect_post(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param endpoint: The endpoint to redirect the channel to (required)
        :type endpoint: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_redirect_post_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501

    def channels_channel_id_redirect_post_with_http_info(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Redirect the channel to a different location.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_redirect_post_with_http_info(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param endpoint: The endpoint to redirect the channel to (required)
        :type endpoint: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'endpoint',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_redirect_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_redirect_post`")  # noqa: E501
        # verify the required parameter 'endpoint' is set
        if self.api_client.client_side_validation and ('endpoint' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint` when calling `channels_channel_id_redirect_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'endpoint' in local_var_params and local_var_params['endpoint'] is not None:  # noqa: E501
            query_params.append(('endpoint', local_var_params['endpoint']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/redirect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_ring_delete(self, channel_id, **kwargs):  # noqa: E501
        """Stop ringing indication on a channel if locally generated.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_ring_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_ring_delete_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_ring_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Stop ringing indication on a channel if locally generated.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_ring_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_ring_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_ring_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/ring', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_ring_post(self, channel_id, **kwargs):  # noqa: E501
        """Indicate ringing to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_ring_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_ring_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_ring_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Indicate ringing to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_ring_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_ring_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_ring_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/ring', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_rtp_statistics_get(self, channel_id, **kwargs):  # noqa: E501
        """RTP stats on a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_rtp_statistics_get(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RTPstat
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_rtp_statistics_get_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_rtp_statistics_get_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """RTP stats on a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_rtp_statistics_get_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RTPstat, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_rtp_statistics_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_rtp_statistics_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "RTPstat",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/rtp_statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_silence_delete(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing silence to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_silence_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_silence_delete_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_silence_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing silence to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_silence_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_silence_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_silence_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/silence', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_silence_post(self, channel_id, **kwargs):  # noqa: E501
        """Play silence to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_silence_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_silence_post_with_http_info(channel_id, **kwargs)  # noqa: E501

    def channels_channel_id_silence_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Play silence to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_silence_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_silence_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_silence_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/silence', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_snoop_post(self, channel_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_snoop_post(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param snoop_id: Unique ID to assign to snooping channel
        :type snoop_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_snoop_post_with_http_info(channel_id, app, **kwargs)  # noqa: E501

    def channels_channel_id_snoop_post_with_http_info(self, channel_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_snoop_post_with_http_info(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param snoop_id: Unique ID to assign to snooping channel
        :type snoop_id: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'app',
            'spy',
            'whisper',
            'app_args',
            'snoop_id',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_snoop_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_snoop_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if self.api_client.client_side_validation and ('app' not in local_var_params or  # noqa: E501
                                                        local_var_params['app'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `app` when calling `channels_channel_id_snoop_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'spy' in local_var_params and local_var_params['spy'] is not None:  # noqa: E501
            query_params.append(('spy', local_var_params['spy']))  # noqa: E501
        if 'whisper' in local_var_params and local_var_params['whisper'] is not None:  # noqa: E501
            query_params.append(('whisper', local_var_params['whisper']))  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'app_args' in local_var_params and local_var_params['app_args'] is not None:  # noqa: E501
            query_params.append(('appArgs', local_var_params['app_args']))  # noqa: E501
        if 'snoop_id' in local_var_params and local_var_params['snoop_id'] is not None:  # noqa: E501
            query_params.append(('snoopId', local_var_params['snoop_id']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/snoop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_snoop_snoop_id_post(self, channel_id, snoop_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_snoop_snoop_id_post(channel_id, snoop_id, app, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param snoop_id: Unique ID to assign to snooping channel (required)
        :type snoop_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_snoop_snoop_id_post_with_http_info(channel_id, snoop_id, app, **kwargs)  # noqa: E501

    def channels_channel_id_snoop_snoop_id_post_with_http_info(self, channel_id, snoop_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_snoop_snoop_id_post_with_http_info(channel_id, snoop_id, app, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param snoop_id: Unique ID to assign to snooping channel (required)
        :type snoop_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'snoop_id',
            'app',
            'spy',
            'whisper',
            'app_args',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_snoop_snoop_id_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_snoop_snoop_id_post`")  # noqa: E501
        # verify the required parameter 'snoop_id' is set
        if self.api_client.client_side_validation and ('snoop_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['snoop_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `snoop_id` when calling `channels_channel_id_snoop_snoop_id_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if self.api_client.client_side_validation and ('app' not in local_var_params or  # noqa: E501
                                                        local_var_params['app'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `app` when calling `channels_channel_id_snoop_snoop_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501
        if 'snoop_id' in local_var_params:
            path_params['snoopId'] = local_var_params['snoop_id']  # noqa: E501

        query_params = []
        if 'spy' in local_var_params and local_var_params['spy'] is not None:  # noqa: E501
            query_params.append(('spy', local_var_params['spy']))  # noqa: E501
        if 'whisper' in local_var_params and local_var_params['whisper'] is not None:  # noqa: E501
            query_params.append(('whisper', local_var_params['whisper']))  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'app_args' in local_var_params and local_var_params['app_args'] is not None:  # noqa: E501
            query_params.append(('appArgs', local_var_params['app_args']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/snoop/{snoopId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_variable_get(self, channel_id, variable, **kwargs):  # noqa: E501
        """Get the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_variable_get(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to get (required)
        :type variable: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Variable
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_variable_get_with_http_info(channel_id, variable, **kwargs)  # noqa: E501

    def channels_channel_id_variable_get_with_http_info(self, channel_id, variable, **kwargs):  # noqa: E501
        """Get the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_variable_get_with_http_info(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to get (required)
        :type variable: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Variable, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'variable',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_variable_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_variable_get`")  # noqa: E501
        # verify the required parameter 'variable' is set
        if self.api_client.client_side_validation and ('variable' not in local_var_params or  # noqa: E501
                                                        local_var_params['variable'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `variable` when calling `channels_channel_id_variable_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'variable' in local_var_params and local_var_params['variable'] is not None:  # noqa: E501
            query_params.append(('variable', local_var_params['variable']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Variable",
        }

        return self.api_client.call_api(
            '/channels/{channelId}/variable', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_channel_id_variable_post(self, channel_id, variable, **kwargs):  # noqa: E501
        """Set the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_variable_post(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to set (required)
        :type variable: str
        :param value: The value to set the variable to
        :type value: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_channel_id_variable_post_with_http_info(channel_id, variable, **kwargs)  # noqa: E501

    def channels_channel_id_variable_post_with_http_info(self, channel_id, variable, **kwargs):  # noqa: E501
        """Set the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_channel_id_variable_post_with_http_info(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to set (required)
        :type variable: str
        :param value: The value to set the variable to
        :type value: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'channel_id',
            'variable',
            'value',
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_variable_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'channel_id' is set
        if self.api_client.client_side_validation and ('channel_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['channel_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_variable_post`")  # noqa: E501
        # verify the required parameter 'variable' is set
        if self.api_client.client_side_validation and ('variable' not in local_var_params or  # noqa: E501
                                                        local_var_params['variable'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `variable` when calling `channels_channel_id_variable_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []
        if 'variable' in local_var_params and local_var_params['variable'] is not None:  # noqa: E501
            query_params.append(('variable', local_var_params['variable']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/channels/{channelId}/variable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_create_post(self, endpoint, app, **kwargs):  # noqa: E501
        """Create channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_create_post(endpoint, app, async_req=True)
        >>> result = thread.get()

        :param endpoint: Endpoint for channel communication (required)
        :type endpoint: str
        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: Unique ID of the calling channel
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_create_post_with_http_info(endpoint, app, **kwargs)  # noqa: E501

    def channels_create_post_with_http_info(self, endpoint, app, **kwargs):  # noqa: E501
        """Create channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_create_post_with_http_info(endpoint, app, async_req=True)
        >>> result = thread.get()

        :param endpoint: Endpoint for channel communication (required)
        :type endpoint: str
        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: Unique ID of the calling channel
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'endpoint',
            'app',
            'app_args',
            'channel_id',
            'other_channel_id',
            'originator',
            'formats',
            'x_asterisk_id',
            'containers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'endpoint' is set
        if self.api_client.client_side_validation and ('endpoint' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint` when calling `channels_create_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if self.api_client.client_side_validation and ('app' not in local_var_params or  # noqa: E501
                                                        local_var_params['app'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `app` when calling `channels_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'endpoint' in local_var_params and local_var_params['endpoint'] is not None:  # noqa: E501
            query_params.append(('endpoint', local_var_params['endpoint']))  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'app_args' in local_var_params and local_var_params['app_args'] is not None:  # noqa: E501
            query_params.append(('appArgs', local_var_params['app_args']))  # noqa: E501
        if 'channel_id' in local_var_params and local_var_params['channel_id'] is not None:  # noqa: E501
            query_params.append(('channelId', local_var_params['channel_id']))  # noqa: E501
        if 'other_channel_id' in local_var_params and local_var_params['other_channel_id'] is not None:  # noqa: E501
            query_params.append(('otherChannelId', local_var_params['other_channel_id']))  # noqa: E501
        if 'originator' in local_var_params and local_var_params['originator'] is not None:  # noqa: E501
            query_params.append(('originator', local_var_params['originator']))  # noqa: E501
        if 'formats' in local_var_params and local_var_params['formats'] is not None:  # noqa: E501
            query_params.append(('formats', local_var_params['formats']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'containers' in local_var_params:
            body_params = local_var_params['containers']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_external_media_post(self, app, external_host, format, **kwargs):  # noqa: E501
        """Start an External Media session.  # noqa: E501

        Create a channel to an External Media source/sink.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_external_media_post(app, external_host, format, async_req=True)
        >>> result = thread.get()

        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param external_host: Hostname/ip:port of external host (required)
        :type external_host: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param encapsulation: Payload encapsulation protocol
        :type encapsulation: str
        :param transport: Transport protocol
        :type transport: str
        :param connection_type: Connection type (client/server)
        :type connection_type: str
        :param direction: External media direction
        :type direction: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_external_media_post_with_http_info(app, external_host, format, **kwargs)  # noqa: E501

    def channels_external_media_post_with_http_info(self, app, external_host, format, **kwargs):  # noqa: E501
        """Start an External Media session.  # noqa: E501

        Create a channel to an External Media source/sink.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_external_media_post_with_http_info(app, external_host, format, async_req=True)
        >>> result = thread.get()

        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param external_host: Hostname/ip:port of external host (required)
        :type external_host: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param encapsulation: Payload encapsulation protocol
        :type encapsulation: str
        :param transport: Transport protocol
        :type transport: str
        :param connection_type: Connection type (client/server)
        :type connection_type: str
        :param direction: External media direction
        :type direction: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'app',
            'external_host',
            'format',
            'channel_id',
            'encapsulation',
            'transport',
            'connection_type',
            'direction',
            'x_asterisk_id',
            'containers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_external_media_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'app' is set
        if self.api_client.client_side_validation and ('app' not in local_var_params or  # noqa: E501
                                                        local_var_params['app'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `app` when calling `channels_external_media_post`")  # noqa: E501
        # verify the required parameter 'external_host' is set
        if self.api_client.client_side_validation and ('external_host' not in local_var_params or  # noqa: E501
                                                        local_var_params['external_host'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `external_host` when calling `channels_external_media_post`")  # noqa: E501
        # verify the required parameter 'format' is set
        if self.api_client.client_side_validation and ('format' not in local_var_params or  # noqa: E501
                                                        local_var_params['format'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `format` when calling `channels_external_media_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'channel_id' in local_var_params and local_var_params['channel_id'] is not None:  # noqa: E501
            query_params.append(('channelId', local_var_params['channel_id']))  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'external_host' in local_var_params and local_var_params['external_host'] is not None:  # noqa: E501
            query_params.append(('external_host', local_var_params['external_host']))  # noqa: E501
        if 'encapsulation' in local_var_params and local_var_params['encapsulation'] is not None:  # noqa: E501
            query_params.append(('encapsulation', local_var_params['encapsulation']))  # noqa: E501
        if 'transport' in local_var_params and local_var_params['transport'] is not None:  # noqa: E501
            query_params.append(('transport', local_var_params['transport']))  # noqa: E501
        if 'connection_type' in local_var_params and local_var_params['connection_type'] is not None:  # noqa: E501
            query_params.append(('connection_type', local_var_params['connection_type']))  # noqa: E501
        if 'format' in local_var_params and local_var_params['format'] is not None:  # noqa: E501
            query_params.append(('format', local_var_params['format']))  # noqa: E501
        if 'direction' in local_var_params and local_var_params['direction'] is not None:  # noqa: E501
            query_params.append(('direction', local_var_params['direction']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'containers' in local_var_params:
            body_params = local_var_params['containers']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels/externalMedia', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_get(self, **kwargs):  # noqa: E501
        """List all active channels in Asterisk.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_get(async_req=True)
        >>> result = thread.get()

        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[Channel]
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_get_with_http_info(**kwargs)  # noqa: E501

    def channels_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all active channels in Asterisk.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[Channel], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'x_asterisk_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[Channel]",
        }

        return self.api_client.call_api(
            '/channels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def channels_post(self, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_post(endpoint, async_req=True)
        >>> result = thread.get()

        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        return self.channels_post_with_http_info(endpoint, **kwargs)  # noqa: E501

    def channels_post_with_http_info(self, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.channels_post_with_http_info(endpoint, async_req=True)
        >>> result = thread.get()

        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param x_asterisk_id:
        :type x_asterisk_id: str
        :param containers: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type containers: Containers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'endpoint',
            'extension',
            'context',
            'priority',
            'label',
            'app',
            'app_args',
            'caller_id',
            'timeout',
            'channel_id',
            'other_channel_id',
            'originator',
            'formats',
            'x_asterisk_id',
            'containers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'endpoint' is set
        if self.api_client.client_side_validation and ('endpoint' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint` when calling `channels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'endpoint' in local_var_params and local_var_params['endpoint'] is not None:  # noqa: E501
            query_params.append(('endpoint', local_var_params['endpoint']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501
        if 'context' in local_var_params and local_var_params['context'] is not None:  # noqa: E501
            query_params.append(('context', local_var_params['context']))  # noqa: E501
        if 'priority' in local_var_params and local_var_params['priority'] is not None:  # noqa: E501
            query_params.append(('priority', local_var_params['priority']))  # noqa: E501
        if 'label' in local_var_params and local_var_params['label'] is not None:  # noqa: E501
            query_params.append(('label', local_var_params['label']))  # noqa: E501
        if 'app' in local_var_params and local_var_params['app'] is not None:  # noqa: E501
            query_params.append(('app', local_var_params['app']))  # noqa: E501
        if 'app_args' in local_var_params and local_var_params['app_args'] is not None:  # noqa: E501
            query_params.append(('appArgs', local_var_params['app_args']))  # noqa: E501
        if 'caller_id' in local_var_params and local_var_params['caller_id'] is not None:  # noqa: E501
            query_params.append(('callerId', local_var_params['caller_id']))  # noqa: E501
        if 'timeout' in local_var_params and local_var_params['timeout'] is not None:  # noqa: E501
            query_params.append(('timeout', local_var_params['timeout']))  # noqa: E501
        if 'channel_id' in local_var_params and local_var_params['channel_id'] is not None:  # noqa: E501
            query_params.append(('channelId', local_var_params['channel_id']))  # noqa: E501
        if 'other_channel_id' in local_var_params and local_var_params['other_channel_id'] is not None:  # noqa: E501
            query_params.append(('otherChannelId', local_var_params['other_channel_id']))  # noqa: E501
        if 'originator' in local_var_params and local_var_params['originator'] is not None:  # noqa: E501
            query_params.append(('originator', local_var_params['originator']))  # noqa: E501
        if 'formats' in local_var_params and local_var_params['formats'] is not None:  # noqa: E501
            query_params.append(('formats', local_var_params['formats']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in local_var_params:
            header_params['X-Asterisk-ID'] = local_var_params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'containers' in local_var_params:
            body_params = local_var_params['containers']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Channel",
        }

        return self.api_client.call_api(
            '/channels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
